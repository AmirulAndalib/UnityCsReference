// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

/******************************************************************************/
//
//                             DO NOT MODIFY
//          This file has been generated by the UIElementsGenerator tool
//              See ResolvedStyleAccessCsGenerator class for details
//
/******************************************************************************/
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public partial class VisualElement : IResolvedStyle
    {
        /// <summary>
        /// The final computed style values on a <see cref="VisualElement"/> (RO).
        /// </summary>
        /// <remarks>
        /// You can use @@resolvedStyle@@ to find the actually rendered styling like width, height, 
        /// or color of an element. For a list of all the supported style properties, refer 
        /// to the [[wiki:UIE-USS-Properties-Reference|USS properties reference]] manual page.
        /// </remarks>
        /// <remarks>
        /// The final computed style combines applied classes, inherited styles from ancestors, and
        /// inline styles defined in UXML or C# code. Therefore, it might be different from what you set through 
        /// the <see cref="VisualElement.style"/> property, depending on the other styles applied to it.
        /// </remarks>
        /// <remarks>
        /// To get the resolved style when the geometry changes, you can use the [[GeometryChangedEvent]] event.
        /// If the element's geometry doesn't change, you can add a scheduler to periodically check the resolved 
        /// style of the element.
        /// For more information about how to use this property and an example of how style changes when layout 
        /// updates, refer to the [[wiki:UIE-apply-styles-with-csharp|Apply styles in C# scripts]] manual page.
        /// </remarks>
        /// <example>
        /// <code lang="cs">
        /// <![CDATA[
        /// // Get the resolved width of the element.
        /// float width = element.resolvedStyle.width;
        /// ]]>
        /// </code>
        /// </example>
        /// <remarks>
        /// SA: [[VisualElement.style]], [[VisualElement.customStyle]]
        /// </remarks>
        public IResolvedStyle resolvedStyle => this;

        Align IResolvedStyle.alignContent => computedStyle.alignContent;
        Align IResolvedStyle.alignItems => computedStyle.alignItems;
        Align IResolvedStyle.alignSelf => computedStyle.alignSelf;
        Color IResolvedStyle.backgroundColor => computedStyle.backgroundColor;
        Background IResolvedStyle.backgroundImage => computedStyle.backgroundImage;
        BackgroundPosition IResolvedStyle.backgroundPositionX => computedStyle.backgroundPositionX;
        BackgroundPosition IResolvedStyle.backgroundPositionY => computedStyle.backgroundPositionY;
        BackgroundRepeat IResolvedStyle.backgroundRepeat => computedStyle.backgroundRepeat;
        BackgroundSize IResolvedStyle.backgroundSize => computedStyle.backgroundSize;
        Color IResolvedStyle.borderBottomColor => computedStyle.borderBottomColor;
        float IResolvedStyle.borderBottomLeftRadius => computedStyle.borderBottomLeftRadius.value;
        float IResolvedStyle.borderBottomRightRadius => computedStyle.borderBottomRightRadius.value;
        float IResolvedStyle.borderBottomWidth => yogaNode.LayoutBorderBottom;
        Color IResolvedStyle.borderLeftColor => computedStyle.borderLeftColor;
        float IResolvedStyle.borderLeftWidth => yogaNode.LayoutBorderLeft;
        Color IResolvedStyle.borderRightColor => computedStyle.borderRightColor;
        float IResolvedStyle.borderRightWidth => yogaNode.LayoutBorderRight;
        Color IResolvedStyle.borderTopColor => computedStyle.borderTopColor;
        float IResolvedStyle.borderTopLeftRadius => computedStyle.borderTopLeftRadius.value;
        float IResolvedStyle.borderTopRightRadius => computedStyle.borderTopRightRadius.value;
        float IResolvedStyle.borderTopWidth => yogaNode.LayoutBorderTop;
        float IResolvedStyle.bottom => yogaNode.LayoutBottom;
        Color IResolvedStyle.color => computedStyle.color;
        DisplayStyle IResolvedStyle.display => computedStyle.display;
        StyleFloat IResolvedStyle.flexBasis => new StyleFloat(yogaNode.ComputedFlexBasis);
        FlexDirection IResolvedStyle.flexDirection => computedStyle.flexDirection;
        float IResolvedStyle.flexGrow => computedStyle.flexGrow;
        float IResolvedStyle.flexShrink => computedStyle.flexShrink;
        Wrap IResolvedStyle.flexWrap => computedStyle.flexWrap;
        float IResolvedStyle.fontSize => computedStyle.fontSize.value;
        float IResolvedStyle.height => yogaNode.LayoutHeight;
        Justify IResolvedStyle.justifyContent => computedStyle.justifyContent;
        float IResolvedStyle.left => yogaNode.LayoutX;
        float IResolvedStyle.letterSpacing => computedStyle.letterSpacing.value;
        float IResolvedStyle.marginBottom => yogaNode.LayoutMarginBottom;
        float IResolvedStyle.marginLeft => yogaNode.LayoutMarginLeft;
        float IResolvedStyle.marginRight => yogaNode.LayoutMarginRight;
        float IResolvedStyle.marginTop => yogaNode.LayoutMarginTop;
        StyleFloat IResolvedStyle.maxHeight => ResolveLengthValue(computedStyle.maxHeight, false);
        StyleFloat IResolvedStyle.maxWidth => ResolveLengthValue(computedStyle.maxWidth, true);
        StyleFloat IResolvedStyle.minHeight => ResolveLengthValue(computedStyle.minHeight, false);
        StyleFloat IResolvedStyle.minWidth => ResolveLengthValue(computedStyle.minWidth, true);
        float IResolvedStyle.opacity => computedStyle.opacity;
        float IResolvedStyle.paddingBottom => yogaNode.LayoutPaddingBottom;
        float IResolvedStyle.paddingLeft => yogaNode.LayoutPaddingLeft;
        float IResolvedStyle.paddingRight => yogaNode.LayoutPaddingRight;
        float IResolvedStyle.paddingTop => yogaNode.LayoutPaddingTop;
        Position IResolvedStyle.position => computedStyle.position;
        float IResolvedStyle.right => yogaNode.LayoutRight;
        Rotate IResolvedStyle.rotate => computedStyle.rotate;
        Scale IResolvedStyle.scale => computedStyle.scale;
        TextOverflow IResolvedStyle.textOverflow => computedStyle.textOverflow;
        float IResolvedStyle.top => yogaNode.LayoutY;
        Vector3 IResolvedStyle.transformOrigin => ResolveTransformOrigin();
        IEnumerable<TimeValue> IResolvedStyle.transitionDelay => computedStyle.transitionDelay;
        IEnumerable<TimeValue> IResolvedStyle.transitionDuration => computedStyle.transitionDuration;
        IEnumerable<StylePropertyName> IResolvedStyle.transitionProperty => computedStyle.transitionProperty;
        IEnumerable<EasingFunction> IResolvedStyle.transitionTimingFunction => computedStyle.transitionTimingFunction;
        Vector3 IResolvedStyle.translate => ResolveTranslate();
        Color IResolvedStyle.unityBackgroundImageTintColor => computedStyle.unityBackgroundImageTintColor;
        Font IResolvedStyle.unityFont => computedStyle.unityFont;
        FontDefinition IResolvedStyle.unityFontDefinition => computedStyle.unityFontDefinition;
        FontStyle IResolvedStyle.unityFontStyleAndWeight => computedStyle.unityFontStyleAndWeight;
        float IResolvedStyle.unityParagraphSpacing => computedStyle.unityParagraphSpacing.value;
        int IResolvedStyle.unitySliceBottom => computedStyle.unitySliceBottom;
        int IResolvedStyle.unitySliceLeft => computedStyle.unitySliceLeft;
        int IResolvedStyle.unitySliceRight => computedStyle.unitySliceRight;
        float IResolvedStyle.unitySliceScale => computedStyle.unitySliceScale;
        int IResolvedStyle.unitySliceTop => computedStyle.unitySliceTop;
        TextAnchor IResolvedStyle.unityTextAlign => computedStyle.unityTextAlign;
        Color IResolvedStyle.unityTextOutlineColor => computedStyle.unityTextOutlineColor;
        float IResolvedStyle.unityTextOutlineWidth => computedStyle.unityTextOutlineWidth;
        TextOverflowPosition IResolvedStyle.unityTextOverflowPosition => computedStyle.unityTextOverflowPosition;
        Visibility IResolvedStyle.visibility => computedStyle.visibility;
        WhiteSpace IResolvedStyle.whiteSpace => computedStyle.whiteSpace;
        float IResolvedStyle.width => yogaNode.LayoutWidth;
        float IResolvedStyle.wordSpacing => computedStyle.wordSpacing.value;
    }
}
